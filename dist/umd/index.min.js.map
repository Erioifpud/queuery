{"version":3,"file":"index.min.js","sources":["../../src/index.js"],"sourcesContent":["export default class Queuery {\n  constructor (options) {\n    const { limit = 3, retries = 3, verbose } = options || {}\n    this.queue = []\n    this.running = 0\n    this.limit = limit\n    this.retries = retries\n    this.results = []\n    this.verbose = verbose\n  }\n\n  task (promiseWrapper, ...args) {\n    this.taskWithName(args, promiseWrapper, ...args)\n  }\n\n  taskWithName (name, promiseWrapper, ...args) {\n    this.queue.push({\n      name,\n      promiseWrapper,\n      args: args.length ? args : [],\n      retries: 0\n    })\n  }\n\n  remove (name) {\n    const index = this.queue.findIndex(item => item.name === name)\n    if (index === -1) {\n      return\n    }\n    this.queue.splice(index, 1)\n    this.verbose && console.log(name, 'removed')\n  }\n\n  __checkNext (done) {\n    if (!this.queue.length) {\n      done()\n      return\n    }\n    const item = this.queue.shift()\n    const { name, promiseWrapper, args, retries } = item\n    if (!retries) {\n      this.running++\n    }\n    const promise = promiseWrapper(...args)\n    promise.then(data => {\n      this.running--\n      this.verbose && console.log(name, 'finished')\n      this.results.push({\n        name,\n        payload: data\n      })\n      this.__checkNext(done)\n      return data\n    }).catch((err) => {\n      if (retries < this.retries) {\n        this.queue.push({\n          ...item,\n          retries: retries + 1\n        })\n        this.verbose && console.log(name, 'is retrying: ', retries)\n        this.__checkNext(done)\n      } else {\n        this.running--\n        this.verbose && console.error(name, 'failed')\n        this.results.push({\n          name,\n          payload: err\n        })\n        this.__checkNext(done)\n        return err\n      }\n    })\n  }\n\n  start (onFinish) {\n    const length = this.queue.length < this.limit ? this.queue.length : this.limit\n    if (!length) {\n      onFinish(this.results)\n      return\n    }\n    const getDone = (resolve) => {\n      let count = 0\n      return () => {\n        count++\n        if (count >= length) {\n          resolve()\n        }\n      }\n    }\n    new Promise((resolve) => {\n      const done = getDone(resolve)\n      for (let i = 0; i < length; i++) {\n        this.__checkNext(done)\n      }\n    }).then(() => {\n      onFinish(this.results)\n    })\n  }\n}\n"],"names":["Queuery","promiseWrapper","args","taskWithName","name","queue","push","length","retries","index","this","findIndex","item","splice","verbose","console","log","done","shift","running","then","data","_this","results","payload","__checkNext","err","error","onFinish","limit","Promise","resolve","count","i","_this2","options"],"mappings":"0kBAAqBA,6CAWbC,8BAAmBC,mCAAAA,yBAClBC,yBAAaD,EAAMD,UAAmBC,yCAG/BE,EAAMH,8BAAmBC,mCAAAA,yBAChCG,MAAMC,KAAK,CACdF,KAAAA,EACAH,eAAAA,EACAC,KAAMA,EAAKK,OAASL,EAAO,GAC3BM,QAAS,mCAILJ,OACAK,EAAQC,KAAKL,MAAMM,UAAU,SAAAC,UAAQA,EAAKR,OAASA,KAC1C,IAAXK,SAGCJ,MAAMQ,OAAOJ,EAAO,QACpBK,SAAWC,QAAQC,IAAIZ,EAAM,gDAGvBa,mBACNP,KAAKL,MAAME,YAIVK,EAAOF,KAAKL,MAAMa,QAChBd,EAAwCQ,EAAxCR,KAAMH,EAAkCW,EAAlCX,eAAgBC,EAAkBU,EAAlBV,KAAMM,EAAYI,EAAZJ,QAC/BA,QACEW,UAESlB,wHAAkBC,0NAC1BkB,KAAK,SAAAC,UACXC,EAAKH,UACLG,EAAKR,SAAWC,QAAQC,IAAIZ,EAAM,YAClCkB,EAAKC,QAAQjB,KAAK,CAChBF,KAAAA,EACAoB,QAASH,IAEXC,EAAKG,YAAYR,GACVI,UACA,SAACK,QACJlB,EAAUc,EAAKd,gBAQjBc,EAAKH,UACLG,EAAKR,SAAWC,QAAQY,MAAMvB,EAAM,UACpCkB,EAAKC,QAAQjB,KAAK,CAChBF,KAAAA,EACAoB,QAASE,IAEXJ,EAAKG,YAAYR,GACVS,EAdPJ,EAAKjB,MAAMC,4cACNM,GACHJ,QAASA,EAAU,KAErBc,EAAKR,SAAWC,QAAQC,IAAIZ,EAAM,gBAAiBI,GACnDc,EAAKG,YAAYR,UAzBnBA,kCAuCGW,cACCrB,EAASG,KAAKL,MAAME,OAASG,KAAKmB,MAAQnB,KAAKL,MAAME,OAASG,KAAKmB,MACpEtB,MAaDuB,QAAQ,SAACC,WATIA,EACXC,EASEf,GAVSc,EAUMA,EARd,WAEQxB,KADbyB,GAEED,MAMKE,EAVLD,EAAQ,EAUIC,EAAI1B,EAAQ0B,IAC1BC,EAAKT,YAAYR,KAElBG,KAAK,WACNQ,EAASM,EAAKX,WAlBdK,EAASlB,KAAKa,2BA5ELY,2GACiCA,GAAW,OAA/CN,MAAAA,aAAQ,QAAGrB,QAAAA,aAAU,IAAGM,IAAAA,aAC3BT,MAAQ,QACRc,QAAU,OACVU,MAAQA,OACRrB,QAAUA,OACVe,QAAU,QACVT,QAAUA"}